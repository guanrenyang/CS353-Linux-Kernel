# 进程地址空间

用户进程的内存称作进程的地址空间

对于一个进程而言，他*好像可以访问整个系统的所有物理内存*

即使是单独一个进程，*它的地址空间也可以远大于系统物理内存*

## 地址空间

### 页式（Page）与段式（Segment）
现代操作系统采用**页式**内存管理：一个进程的地址空间与另一个进程的地址空间即使拥有相同的内存地址，实际上彼此也互不相干。

进程之间的地址是隔离的，线程之间共用一个地址空间。
**页式**与**段式**内存管理的区别：
*假设系统中物理地址为0-19*

1. 段式内存管理物理内存分为段（segment），例如将0-19分为两个段——0-9和10-19。在给进程分配地址时将段分配给进程，例如将段0-9分配给0号进程，10-19分配给1号进程。***每个进程看到的地址是不同的***，且 ***所有进程地址空间之和为物理地址空间***。

2. 页式内存管理（具体内容细说），***每个进程看到的地址空间时相同的***，例如都是0-9。但是系统会将0号进程的地址映射到物理内存中的长度为10的片段上，将1号进程的地址映射到另一个长度为10的物理片段上。 ***进程看到的地址（虚拟地址）可以大于物理地址***，因为并不是所有页都必须要存储在内存上，有些页还可以存储在磁盘上。

### 内存区域

每一个内存地址都对应**唯一的**一个字节。

32位内存地址可以寻址4GB(2^32)，64位内存地址可以索引8GB(2^64)。

虽然一个进程可以索引4G或8G内存区域，但是 ***并不代表它有权限访问地址空间中的所有内容***。可以被合法访问的地址空间称作**内存区域**。

当进程1. 访问内存区域意外的内容或2. 以非法方式访问内存区域，就会终止进程并抛出**Segmentation Fault**

#### 内存区域中的重要内存对象

1. 代码段（text section）：可执行文件代码（2进制）保存的地方。例如代码段为0-9，那就将2进制代码存储在地址为0-9的这10个Byte上。（事实上代码段的作用还需要细查）
2. 全局变量对应的段：**数据段**和**bbs段的零页**。数据段保存着*已初始化* 的全局变量；bbs（block started by symbol）是一些 ***值全为0*** 的页，那些*未被初始化* 的全局变量就会被映射到这些零页上。

## 内存描述符

内存描述符用于**表示进程的地址空间**，它含有与地址空间相关的一切信息。内存描述符`mm_struct`定义在`<linux/sched.h>`中，它是进程描述符`task_struct`的一个成员变量（变量名`mm`），可以通过获取进程的`task_struct`来获取`mm_struct`。
